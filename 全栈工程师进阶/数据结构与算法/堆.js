// 1.1关键码
// 在数据记录中存在一个能够标识数据记录的数据项，并可依据该数据项对数据进行组织，则称此数据项为关键码key

// 在最小堆中，父节点的关键码小于等于它的左右子女的关键码；
// 最大堆中，父节点的关键码大于等于左右子女的关键码

//        9   最小堆，任何一个父节点都小于他直接的左右两个孩子节点
//     ↙    ↘
//     17       65
//   ↙ ↘      ↙   ↘
//   23   45    78    87
// ↙ ↘
// 53  31

//        87   最大堆，任何一个父节点都大于他直接的左右两个孩子节点
//     ↙    ↘
//     78       53
//   ↙ ↘      ↙   ↘
//  45   65    9    31  ：序号(2*i)+2 ,2*3=6
// ↙ ↘
// 17 23             13   14   (2*6)+2 2*7=14 (14-1)/2=6.5=6

// 数组中的索引从0开始，元素个数为n，在堆中给定索引为i的节点时：
//  如果i=0,节点i是根节点，否则节点i的父节点时(i-1)/2
//  如果2*i +1>n-1，则节点i无左子女，否则节点i的左子女为2*i+1
//  如果2*i +2>n-1，则节点i无左子女，否则节点i的右子女为2*i+2

//数组初始化最小堆 [53,17,78,9,45,65,87,23]
// 过程是自下而上
// 1找到所有的分支节点（除最后没有左右子女的节点）,53\17\78\9
// 2根据这些分支节点的索引从大到小一次进行调整,先最下面开始调整,然后往上的意思9->78->17->53
// ，然后该分支节点向下调整,和左右子女比较，换位置，谁小在上面 9和他的两个直接子女比较,然后78节点开始和左右子女比较;
// 然后17和左右子女比较;最左边开始比较,17和23比较..最后53和他的左右子女比较

//        53
//     ↙    ↘
//     17       78
//   ↙ ↘      ↙   ↘
//  9   45    65      87
//↙
//23
35
// 最小堆实现：类定义
function MinHeap(size) {
  var heap = new Array(size) //数组
  var curr_size = 0 //当前堆的大小
  var max_size = size //堆最大容量，规定最大放进来5个数
}
var shif_down = function (start, m) { //m是数组中最大的索引
  // 从start这个位置开始，向下下滑调整
  var parent_index = start //start就是当前这个局部的父节点
  //一定有左孩子，先让min_child_index等于左孩子的;

  var min_child_index = parent_index * 2 + 1;
while(min_child_index<=m){ 
  if()
}
}
this.init = function (arr) {
  // 容量
  max_size = arr.length
  curr_size = max_size
  heap = new Array(arr.length)
  // 填充heap,目前还不是一个堆
  for (let i = 0; i < curr_size.length; i++) {
    heap[i] = arr[i]
  }
  //堆的最后一个分支节点:(数组的最后一个元素是数组长度-1 他的父节点是-1 ) /再除以2
  var curr_pos = Math.floor((curr_size - 2) / 2)
  while (curr_pos >= 0) {
    // 局部自上向下下滑调整
    shift_down(curr_pos, curr_size - 1)
    // 调整下一个分支节点
    curr_pos -= 1
  }
}
104-127
// 题目：一个非常大的数据集合有n个数，求集合中最大的K个值:快排、最小堆、分治法
// 用最小堆来算，非常简单，初始化一个大小为k的最小堆，先放入k个数，这时，堆顶元素最小，集合中
// 剩余的数一次次和堆顶元素比较，如果比堆顶元素大，则删除堆顶元素，并放入新的元素，全部比较以后，
// 堆里的元素就是最大的K个值
// 比如求数组中最大的3个数，先拿出3个数放在堆里，堆会自动排序，然后依次在数组中拿出一个数比较，是不是比堆最小的还小，说明这个数就不是大的数，忽略。
// 如果这个数比最小的大，说明是个大一点的数，那么删除堆顶最小的数，把这个大一点数放进去
var arr=[53,17,78,9,45,65,87,23]
var min_heap=new MinHeap(3)
for (let i = 0; i < 3; i++) {
  min_heap.insert(arr[i])
  
}
for (let i = 0; i < arr.length; i++) {
  const item = arr[i];
  if(item>min_heap.get_min()){ 
    min_heap.remove_min()
    min_heap.insert(item)
  }
}
min_heap.print()